[{"title":"gorm save error when model not changed","date":"2023-10-17T02:57:24.032Z","path":"2023/10/17/gorm-save-error-when-model-not-changed/","text":"gorm的save使用中，发现当模型通过save保存时，如果模型没有发生改变，会包主键冲突错误，这只在事务中出现，独立使用save同样的场景不会报错。 错误使用grom的save初衷是想存在时更新，不存在时自动创建，在模型不变时执行save报下面的错误Error 1062 (23000): Duplicate entry &#39;336ea11bd7254ee7bb406604bfa43bf2&#39; for key &#39;histories.PRIMARY&#39; 错误code使用事务并遍历保存模型的原因是，save没有设置批量个数的方式，当一次保存的模型数过大时，会引发错误（具体数和硬件配置等有关），所以为了避免，显示的做了事务循环更新 err := r.db.Transaction(func(tx *gorm.DB) error &#123; for _, m := range newModels &#123; if err := tx.Save(m).Error; err != nil &#123; return err &#125; &#125; return nil &#125;) 错误分析grom的save在很多地方都使用，从来没遇到过这个错误，并且save的逻辑是会先判断存在更新，不存在创建，所以出现主键重复的错误很奇怪，debug数据发现只会出现子更新的数据没有任何变化的情况下。确认了重现的场景，但还是不太能理解错误的原因，于是又写了测试代码来验证save,最终发现，直接使用save即使模型不变也不会出现问题，只会在事务中出现问题。 解决办法在更新模型前加了判断，如果没有变化就直接跳过了（业务中本身有对变化字段的处理，只是一开始没处理这个分支）","comments":true,"tags":[]},{"title":"proto文件通过gitlab CI自动生成js文件","date":"2023-03-18T02:23:44.000Z","path":"2023/03/18/protobuf-generate-js-by-gitlab-ci/","text":"项目使用了grpc，前端希望每次proto文件有修改时，能自动生成对应的js文件并提交到前端js文件的仓库，于是研究了下gitlab ci，做个记录。 我这边因为用的微服务，每个服务独立一个git仓库，每个服务对应的proto文件也在各自服务的git仓库，所以通过gitlab群组的CI/CD配置定义了几个共用的变量以及整个生成的脚本，方便不同的服务仓库共享。 生成脚本proto生成js的命令1protoc --proto_path=. --proto_path=../../../protobuf --js_out=import_style=commonjs,binary:. --grpc-web_out=import_style=typescript,mode=grpcweb:. xxx/xxxx.proto 根据git的修改记录生成对应的js文件12345files=$(git diff --name-only HEAD~ | grep &#x27;\\.proto&#x27;)for filePath in $filesdo protoc --proto_path=. --proto_path=../../../protobuf --js_out=import_style=commonjs,binary:. --grpc-web_out=import_style=typescript,mode=grpcweb:. $filePathdone; 提交新生成的js文件到git仓库1234567891011tsFiles=$(find ./ -name *.ts -type f)git clone --depth 1 --branch master $TS_PROTO_REPOSITORY_ADDRfor tsfilePath in $tsFilesdo echo &quot;----cp $tsfilePath------&quot; cp --parents $tsfilePath ./$TS_PROTO_REPOSITORY_NAMEdone;cd ./$TS_PROTO_REPOSITORY_NAME/git add .;git commit -m &quot;ci通过$&#123;CI_PROJECT_PATH&#125;中$&#123;GITLAB_USER_NAME&#125;的提交$&#123;CI_COMMIT_SHORT_SHA&#125;同步&quot; -m &quot;$&#123;CI_COMMIT_MESSAGE&#125;&quot; || true;git push; $TS_PROTO_REPOSITORY_NAME 是gitlab的CI/CD中定义的要提交生成js文件的git仓库地址 $TS_PROTO_REPOSITORY_NAME 是gitlab的CI/CD中定义的要提交生成js文件的git仓库名称gitlab ci配置12345678910ts: stage: build only: - master extends: - .template script: - chmod +x $GENERATE_TS_BY_PROTO_SCRIPT - $GENERATE_TS_BY_PROTO_SCRIPT $GENERATE_TS_BY_PROTO_SCRIPT是在gitlab的CI/CD配置中，配置的一个文件类型的变量，主要是把上面的shell脚本整合在一个文件里面，定义在gitlab的群组里面，群组下面的所有git仓库（我是微服务，每个服务一个独立的git仓库）可以共用。 配置文件类型的变量需要特别注意，不能勾选Expand variable reference这个选项，否则脚本中定义的变量会被提前扩展出来（扩展的时候脚本没执行，没有值），导致脚本执行失败。 下面是$GENERATE_TS_BY_PROTO_SCRIPT的完整内容：1234567891011121314151617181920212223#!/bin/bashif [ -z &quot;$(git diff --name-only HEAD~ | grep &#x27;\\.proto&#x27;)&quot; ]; then echo &quot;no proto file changed!&quot; exit 0fifiles=$(git diff --name-only HEAD~ | grep &#x27;\\.proto&#x27;)for filePath in $filesdo protoc --proto_path=. --proto_path=../../../protobuf --js_out=import_style=commonjs,binary:. --grpc-web_out=import_style=typescript,mode=grpcweb:. $filePathdone;tsFiles=$(find ./ -name *.ts -type f)git clone --depth 1 --branch master $TS_PROTO_REPOSITORY_ADDRfor tsfilePath in $tsFilesdo echo &quot;----cp $tsfilePath------&quot; cp --parents $tsfilePath ./$TS_PROTO_REPOSITORY_NAMEdone;cd ./$TS_PROTO_REPOSITORY_NAME/git add .;git commit -m &quot;ci通过$&#123;CI_PROJECT_PATH&#125;中$&#123;GITLAB_USER_NAME&#125;的提交$&#123;CI_COMMIT_SHORT_SHA&#125;同步&quot; -m &quot;$&#123;CI_COMMIT_MESSAGE&#125;&quot; || true;git push;","comments":true,"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://ioridy.github.io/tags/gitlab/"},{"name":"protobuf","slug":"protobuf","permalink":"http://ioridy.github.io/tags/protobuf/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://ioridy.github.io/tags/CI-CD/"}]},{"title":"带参数的微信小程序码服务端(golang)生成","date":"2023-03-17T02:01:07.000Z","path":"2023/03/17/qrcode-for-wechat-mini-program-with-golang/","text":"官方接口微信小程序码共有3个接口可以生成： 获取小程序码 POST https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN 该接口用于获取小程序码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制 path参数指定扫码进入的页面，最大长度 1024 字节，不能为空可以带参数page/example?foo=bar 获取不限制的小程序码 POST https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESS_TOKEN 该接口用于获取小程序码，适用于需要的码数量极多的业务场景。通过该接口生成的小程序码，永久有效，数量暂无限制 page参数指定扫码进入的页面，非必要参数，不可以带参数page/example 获取小程序二维码 POST https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN 获取小程序二维码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制 path参数指定扫码进入的页面，最大长度 128 字节，不能为空，可以带参数page/example?foo=bar 以上3个接口之间的差异主要在于参数以及可以生成的数量， 接口1和3整体差异比较少（path参数长度不同； 小程序码和小程序二维码）,接口2生成数量不受限制，但是指定打开的页面的参数page不能带参数（可以考虑通过scene参数传递，我目前还没验证） 具体的差异和参数可以通过链接查看官方文档 Golang实现我根据自己的需要，选择了接口1的形式来实现，其他的接口只是接口url和参数的差异，整体流程和调用方式都是一样的。 获取ACCESS_TOKEN123456789101112131415161718192021222324252627282930313233343536func requestToken(appid, secret string) (string, error) &#123; u, err := url.Parse(&quot;https://api.weixin.qq.com/cgi-bin/token&quot;) if err != nil &#123; log.Fatal(err) &#125; paras := &amp;url.Values&#123;&#125; //设置请求参数 paras.Set(&quot;appid&quot;, appid) paras.Set(&quot;secret&quot;, secret) paras.Set(&quot;grant_type&quot;, &quot;client_credential&quot;) u.RawQuery = paras.Encode() resp, err := http.Get(u.String()) //关闭资源 if resp != nil &amp;&amp; resp.Body != nil &#123; defer resp.Body.Close() &#125; if err != nil &#123; return &quot;&quot;, errors.New(&quot;request token err :&quot; + err.Error()) &#125; jMap := make(map[string]interface&#123;&#125;) err = json.NewDecoder(resp.Body).Decode(&amp;jMap) if err != nil &#123; return &quot;&quot;, errors.New(&quot;request token response json parse err :&quot; + err.Error()) &#125; if jMap[&quot;errcode&quot;] == nil || jMap[&quot;errcode&quot;] == 0 &#123; accessToken, _ := jMap[&quot;access_token&quot;].(string) return accessToken, nil &#125; else &#123; //返回错误信息 errcode := jMap[&quot;errcode&quot;].(string) errmsg := jMap[&quot;errmsg&quot;].(string) err = errors.New(errcode + &quot;:&quot; + errmsg) return &quot;&quot;, err &#125;&#125; 获取小程序码12345678910111213141516171819202122232425262728293031323334353637func GetQRCode(id string) ([]byte, error) &#123; //上面生成的access code 判断为空时重新请求 if appAccessTokenForClient == &quot;&quot; &#123; accessToken, err := requestToken(appId, appSecret) if err != nil &#123; return nil, err &#125; appAccessTokenForClient = accessToken &#125; strUrl := fmt.Sprintf(&quot;https://api.weixin.qq.com/wxa/getwxacode?access_token=%s&quot;, appAccessTokenForClient) parm := make(map[string]string) parm[&quot;path&quot;] = fmt.Sprintf(&quot;pages/index/index?id=%s&quot;, id) jsonStr, err := json.Marshal(parm) if err != nil &#123; return nil, errors.New(&quot;json Marshal QRCode paramter err :&quot; + err.Error()) &#125; req, err := http.NewRequest(&quot;POST&quot;, strUrl, bytes.NewBuffer([]byte(jsonStr))) if err != nil &#123; return nil, errors.New(&quot;get QRCode err :&quot; + err.Error()) &#125; req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) client := &amp;http.Client&#123;&#125; resp, err := client.Do(req) if err != nil &#123; return nil, errors.New(&quot;get QRCode err :&quot; + err.Error()) &#125; defer resp.Body.Close() body, err := io.ReadAll(resp.Body) if err != nil &#123; return nil, errors.New(&quot;get QRCode err :&quot; + err.Error()) &#125; return body, nil&#125; 常见问题整个过程主要在调试时比较费时间，微信接口返回的错误信息比较范，记录下主要遇到的几种问题 40159&#123;\\&quot;errcode\\&quot;:40159,\\&quot;errmsg\\&quot;:\\&quot;invalid length for path, or the data is not json string hint: [Id2VBa0339xa11]\\&quot;&#125; 主要是检查传递的参数，特别是path对应的长度 我这边是因为从接口2修改为接口1，但是page参数名没有修改为path，导致系统判断path为空，一直提示此错误 40169errCode: 40169 errMsg: &quot;openapi.wxacode.getUnlimited:fail invalid length for scene, or the data is not json string rid: 62764ad3-09f60c12-58046222&quot; 接口2中scene参数，最大32个可见字符，只支持数字，大小写英文以及部分特殊字符：!#$&amp;’()*+,/:;=?@-._~，其它字符请自行编码为合法字符（因不支持%，中文无法使用 urlencode 处理，请使用其他编码方式）","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"wechat","slug":"wechat","permalink":"http://ioridy.github.io/tags/wechat/"}]},{"title":"跨域(CROS)时GET和POST正常但PUT和DELETE被阻止","date":"2023-03-15T02:14:04.000Z","path":"2023/03/15/cros_put_error/","text":"问题表现同一个项目请求同一个服务时，Get和Post请求正常，但是Put和Delete一直报跨域错误的问题 1Access to XMLHttpRequest at &#x27;http://127.0.0.1:8011/api/organization&#x27; from origin &#x27;http://localhost:9527&#x27; has been blocked by CORS policy: Method PUT is not allowed by Access-Control-Allow-Methods in preflight response. 解决方案根据问题描述，很清楚是PUT方法不行，于是去查看服务端的跨域中间件， 发现没有在Header中明确指定Access-Control-Allow-Headers,于是添加Allow Methods的设置,， 以下是完整的跨域中间件： 1234567891011121314151617181920212223package middlewareimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)func CORSMiddleware() gin.HandlerFunc &#123; return func(ctx *gin.Context) &#123; ctx.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;) //出问题是缺少这里 ctx.Writer.Header().Set(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;) if ctx.Request.Method == http.MethodOptions &#123; ctx.AbortWithStatus(200) &#125; else &#123; ctx.Next() &#125; &#125;&#125; 反思问题本身没有什么，但有意思的是过程，因为我先写的服务端，且确定加了跨域的中间件，且在写前端的时候，之前常用的Get和Post访问都没有出现跨域的问题，所以问题出现时，没有第一时间联系到时服务端的问题。网上查了些信息，整体描述是因为Get和Post的方法是默认的，所以及时没有明确设置也可以通过，但是其他的方法就需要显示的设置。","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"}]},{"title":"broker and event in go-micro","date":"2022-01-22T03:41:52.000Z","path":"2022/01/22/go-micro-broker-and-event/","text":"在调研broker的具体实现时，发现之前项目中的消息发送，是使用的Client(publish)/Server(subscribe)的方式，并没有直接使用broker，于是决定调研下这两者是什么关系。 Brokerbroker是go-micro自身定义的异步Pub/Sub interface， 不同的机制（kafka、mqtt、nats…)最终只需要实现对应的接口，即可支持go-micro的异步消息发布/订阅。 12345678910type Broker interface &#123; Init(...Option) error Options() Options Address() string Connect() error Disconnect() error Publish(topic string, m *Message, opts ...PublishOption) error Subscribe(topic string, h Handler, opts ...SubscribeOption) (Subscriber, error) String() string&#125; Eventevent是go-micro基于broker的interface封装的一个基于protobuf的消息发送/订阅模块， 即最终还是依赖broker的实现（go-micro默认提供一个点对点http代理)，所以只需要使用plugin的方式，修改了broker的实现， event即可应用。 Event只定义了Publish接口 (micro.go) 12345678// Event is used to publish messages to a topictype Event interface &#123; // Publish publishes a message to the event topic Publish(ctx context.Context, msg interface&#123;&#125;, opts ...client.PublishOption) error&#125;// Type alias to satisfy the deprecationtype Publisher = Event Client中Publish (client/client.go) 12345678910111213// Client is the interface used to make requests to services.// It supports Request/Response via Transport and Publishing via the Broker.// It also supports bidirectional streaming of requests.type Client interface &#123; Init(...Option) error Options() Options NewMessage(topic string, msg interface&#123;&#125;, opts ...MessageOption) Message NewRequest(service, endpoint string, req interface&#123;&#125;, reqOpts ...RequestOption) Request Call(ctx context.Context, req Request, rsp interface&#123;&#125;, opts ...CallOption) error Stream(ctx context.Context, req Request, opts ...CallOption) (Stream, error) Publish(ctx context.Context, msg Message, opts ...PublishOption) error String() string&#125; Server中Subscribe (server/server.go) 123456789101112// Server is a simple micro server abstractiontype Server interface &#123; Options() Options Init(...Option) error Handle(Handler) error NewHandler(interface&#123;&#125;, ...HandlerOption) Handler NewSubscriber(string, interface&#123;&#125;, ...SubscriberOption) Subscriber Subscribe(Subscriber) error Start() error Stop() error String() string&#125; micro中RegisterSubscriber (micro.go) 1234// RegisterSubscriber is syntactic sugar for registering a subscriberfunc RegisterSubscriber(topic string, s server.Server, h interface&#123;&#125;, opts ...server.SubscriberOption) error &#123; return s.Subscribe(s.NewSubscriber(topic, h, opts...))&#125; grpc实现的Server中Subscribe (server/grpc/grpc.go) 1234567891011121314151617181920func newGRPCServer(opts ...server.Option) server.Server &#123; options := newOptions(opts...) // create a grpc server srv := &amp;grpcServer&#123; opts: options, rpc: &amp;rServer&#123; serviceMap: make(map[string]*service), &#125;, handlers: make(map[string]server.Handler), subscribers: make(map[*subscriber][]broker.Subscriber), exit: make(chan chan error), wg: wait(options.Context), &#125; // configure the grpc server srv.configure() return srv&#125; 异同基于以上的分析， 直接使用Broker实现的Publish/Subscribe和使用go-micro中封装的Event实现的Publish/Subscribe本质是相同的，但是在使用的时候还是有一点差异： Event的Body可以使用proto定义的message，Broker的body只能是[]byte Event的Header需要通过context传递到底层， Broker直接设置header 同一个topic使用两种方式都可以接受到，但是通过Broker直接发布的消息， Event订阅接受后，会提示序列化错误","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"http://ioridy.github.io/tags/go-micro/"},{"name":"micro","slug":"micro","permalink":"http://ioridy.github.io/tags/micro/"},{"name":"broker","slug":"broker","permalink":"http://ioridy.github.io/tags/broker/"}]},{"title":"go-micro broker with RabbitMQ","date":"2022-01-16T22:55:28.000Z","path":"2022/01/17/go-broker-rabbitmq/","text":"之前有简单了解过go-micro的broken以及默认的http实现（参考：go-micro中的发布订阅Broker分析）），目前因为消息数量以及稳定性的需要，想引用消息队列，初步了解了下RabbitMQ的在go-micro中的应用。 安装RabbitMQ我这边是macOS直接使用brew命令安装的：12brew updatebrew install rabbitmq 安装完成后，还需要把rabbitmq的路径加入到PATH中，方便之后命令行使用CLI tools执行相应的用户和权限的操作。 brew自动安装完成后会在/usr/local/sbin下面创建rabbitmq可执行程序的软链，所以只需要确保/usr/local/sbin在环境的PATH即可 rabbitmq的安装完成后的目录/usr/local/Cellar/rabbitmq/&lt;version&gt;/ 其他的方式或者系统可参考RabbitMQ的官方文档Installation Guides RabbitMQ实现的go-micro broker plugingithub上已经有实现好的plugin，我们直接使用即可，地址：rabbitmq for go-micro broker plugin go.mod中添加plugin12github.com/micro/go-micro/v2 v2.5.0github.com/micro/go-plugins/broker/rabbitmq/v2 v2.5.0 这里使用的时候需要注意plugin的version和go-micro使用的version匹配。 我本来使用的是go-micro v2.4.0的版本，但是plugin没有对应匹配的版本，所以我升级到了v2.5.0，最终go-micro和plugin都使用了v2.5.0的版本。 main.go中初始化RabbitMQ 12345678910b := rabbitmq.NewBroker( broker.Addrs(&quot;amqp://username:password@localhost:5672&quot;), ) if err := b.Init(); err != nil &#123; log.Fatalf(&quot;Broker Init error: %v&quot;, err) &#125; if err := b.Connect(); err != nil &#123; log.Fatalf(&quot;Broker Connect error: %v&quot;, err) &#125; Publish/Subscribe中这部分初始化是一样的 main.go中设置service中的broker实现 123456// New Service service := micro.NewService( micro.Name(&quot;ioridy.micro.api.hello&quot;), micro.Version(&quot;latest&quot;), micro.Broker(b), //默认是http实现，需要执行替换 ) 这里有个小点需要提醒下，如果你直接使用broker中的接口做Publish/Subscribe，是不需要上面这样设置service中broker的实现的，这个替换是针对使用micro下封装的Event 以上就已经完成了RabiitMQ在go-micro中的使用，之后只需要按照broker中的接口使用即可。 Publish/Subscribe最后还是放个Publish/Subscribe的实际例子供参考下 Publish 123456789101112131415161718const DemoTopic = &quot;ioridy.micro.msg.hello&quot;var count = 1func MessagePublish(msg string) &#123; message := &amp;broker.Message&#123; Header: map[string]string&#123; &quot;count&quot;: fmt.Sprintf(&quot;%d&quot;, count), &#125;, Body: []byte(&quot;this is event body&quot;), &#125; count += 1 if err := broker.Publish(DemoTopic, message); err != nil &#123; log.Infof(&quot;[Hello pub] failed: %v&quot;, err) &#125; else &#123; log.Infof(&quot;[Hello pub] pubbed message:&quot;, string(message.Body)) &#125;&#125; Subscribe 12345678910111213141516171819202122const DemoTopic = &quot;ioridy.micro.msg.hello&quot;// Example of a shared subscription which receives a subset of messagesfunc sharedSub() &#123; _, err := broker.Subscribe(DemoHelloTopic, func(p broker.Event) error &#123; fmt.Println(&quot;[Word sharedSub] received message:&quot;, string(p.Message().Body), &quot;header&quot;, p.Message().Header) return nil &#125;, broker.Queue(&quot;consumer&quot;)) if err != nil &#123; fmt.Println(err) &#125;&#125;// Example of a subscription which receives all the messagesfunc sub() &#123; _, err := broker.Subscribe(DemoHelloTopic, func(p broker.Event) error &#123; fmt.Println(&quot;[World sub] received message:&quot;, string(p.Message().Body), &quot;header&quot;, p.Message().Header) return nil &#125;) if err != nil &#123; fmt.Println(err) &#125;&#125; 以上部分的Subscribe需要放在main.go中初始化的","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"http://ioridy.github.io/tags/go-micro/"},{"name":"micro","slug":"micro","permalink":"http://ioridy.github.io/tags/micro/"},{"name":"broker","slug":"broker","permalink":"http://ioridy.github.io/tags/broker/"}]},{"title":"Aliyun STS golang sdk Error (405:Method Not Allowed)","date":"2021-01-29T06:33:09.000Z","path":"2021/01/29/aliyun-sts-405-method-not-allowed/","text":"之前用的aliyun golang sdk 完成了STS的授权功能，今天因为要加短信的功能，就顺便升级了aliyun golang sdk的版本，编译没有任何问题，结果发布的时候发现之前sts的获取token接口报405:Method Not Allowed， 因为没有改任何code，知道是因为sdk升级带来的问题，但是不清楚是因为什么，于是debug了下，找到了原因记录下。 问题debug发现新版本sdk的出现问题是因为sdk内部根据传入的regionId计算出来的endpoint错误，导致405错误， 所以修改了regionId即可正确访问。 上面找到问题后，就好奇为什么同样的配置旧版本的sdk就可以调用成功能，于是有切换了旧版sdk做了debug后发现，主要是旧版本的enpoint解析在几个分支都失败后，会有个全局默认的，所以最终可以得到一个正确的endpoint，但是新版的解析器逻辑修改了，导致了问题出现。 关于regionId这里要注意: 我用到的OSS有自己的regionId，会根据你买服务的地区不同而不同，设置错误无法访问 OSS的regionId(比如我用的：oss-cn-beijing)的格式和其他(比如STS和SMS的都是：cn-hangzhou)都不同，我这边的错误就是因为要做OSS业务，看到sdk要regionId参数，就直接使用了（旧版本sdk还正确访问了- -!） STS没有自己的regionId，是在系统给的自己选（但是sdk里面不同的regionId还是都匹配到同一个host，不了解逻辑是做什么） ps: sdk里面的endpoint解析逻辑有点复杂，不清楚业务背景不太懂为什么要这样做，比如外边设置了regionId，但里面都用EndpointMap被匹配到一个host，很奇怪。","comments":true,"tags":[{"name":"aliyun","slug":"aliyun","permalink":"http://ioridy.github.io/tags/aliyun/"},{"name":"sts","slug":"sts","permalink":"http://ioridy.github.io/tags/sts/"}]},{"title":"golangci-lint timeout","date":"2021-01-22T12:01:45.000Z","path":"2021/01/22/golangci-lint-timeout/","text":"在gitlab的ci里面配置了golangci-lint检查，但是偶尔总出现level=error msg=&quot;Timeout exceeded: try increasing it by passing --timeout option&quot;这种错误， 重新执行一次就正常了，虽然几率小，但还是会造成困扰，于是找了下问题，分享下解决方案。 错误 解决方法在golangci-lint运行时，加上timeout的参数设置(默认是1分钟) 123golangci-lint run ./... --timeout=10m 详细的信息可以通过命令行的help查看:golangci-lint run -h","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"golangci","slug":"golangci","permalink":"http://ioridy.github.io/tags/golangci/"}]},{"title":"http的get请求中的url中添加Object参数","date":"2021-01-18T12:13:06.000Z","path":"2021/01/18/pass-object-parameters-with-url-in-http-get-request/","text":"一直以来http的get请求中，都没有尝试带过复杂对象参数，最新在写grpc时， 使用了框架自动转化rpc请求到http请求，参数定义时没有注意复杂度，定义了个对象嵌套对象的请求参数，所以尝试了下载请求的url中携带对象参数的方案。 先说解决方案， 把对象序列化成字符串，encode然后加到url中即可。 请参考下面的sample： 结果 server端定义的请求参数对象 123456789101112type HelloRequest struct &#123; Id int32 Name string User *User &#125;type User struct &#123; Id int32 Name string &#125; 前端发送请求 12345678var helloRequest = &#123;&quot;id&quot;: 2,&quot;name&quot;: &quot;User&quot;,&#125;var helloRequestString = encodeURI(JSON.stringify(helloRequest)) var url = &#x27;http://localhost:8080/v2/hello?id=1&amp;name=hello&amp;user=&#x27; + helloRequestStringvar ajaxObj = new XMLHttpRequest();ajaxObj.open(&#x27;get&#x27;, url);ajaxObj.send(); 只需要把第一层里面嵌套的对象序列化即可","comments":true,"tags":[{"name":"http","slug":"http","permalink":"http://ioridy.github.io/tags/http/"}]},{"title":"go-micro的grpc请求中context复用问题","date":"2021-01-12T14:56:04.000Z","path":"2021/01/12/grpc-context/","text":"今天在处理数据复制时，rpc请求进来后，做了个异步的流程，起了goroutine做数据复制后，rpc的接口直接ruturn了。 结果发现go routine中对其他服务的请求一直失败，debug后发现是因为go routine中发起对其他服务请求时一直提示context报错。 持续跟进发现是因为用的context是复用的GRPC接口中的context。 当GGRPC被return结束后， context会被设置成cancel的状态导致后续依赖次context的地方会失败。 12345678func (s *ExampleService) AsyncCall (ctx context.Context, req *examp.In) (*examp.Out, error) &#123; go func(req *examp.In) &#123; time.Sleep(3 * time.Second) err := client.ExamplaGrpcCall(ctx, req) //call another grpc method will return error &#125;(req) return nil, nil&#125; 像上面这种sample中的ExamplaGrpcCall方法就无法访问成功，因为在请求前context已经被修改为cannel状态了。 解决办法也很简单： 重新建一个context而不要依赖GRPC原有的context。 如果服务之间有鉴权，新建的context需要从GRPC中的context中复制这部分信息。","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"http://ioridy.github.io/tags/go-micro/"},{"name":"grpc","slug":"grpc","permalink":"http://ioridy.github.io/tags/grpc/"}]},{"title":"golang中使用module管理版本(v2.x及以上的情况)","date":"2020-11-04T08:01:17.000Z","path":"2020/11/04/golang-module-version/","text":"一直用golang写业务代码，最近改动升级项把common module的version升级的v2，结果尴尬了，于是查了下文档，随手记录下v2.x及以后得版本的使用方法。 golang中module的版本管理分路径和版本号两部分，路径是go.mod中开始module后面定义的， 而version是按照git tag获取的，两部分组合在一起决定了一个唯一的版本。 PS：上面描述的version只是go.mod中通用的描述，其他如果没有tag，或使用commit以及时间组成一个唯一识别符等其他的情况，可以去文档详细了解 v2以下（v0/v1）12345678910$ cat go.modmodule example.com/hellogo 1.12require ( golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c //没有tag时，直接引用的是最新一个commit rsc.io/quote v1.5.2 rsc.io/sampler v1.3.0 //常规) v2.x及以上 区别于v1的版本，v2.x及以后得版本，都需要path和version匹配，及大版本需要在path中体现。 123456789$ cat go.modmodule example.com/hello/v2 //如果要发布v2.x的版本，这里一定要加上v2go 1.12require ( github.com/golang/mock v1.3.1 github.com/micro/go-micro/v2 v2.3.0 //这里是v2.3.0的版本，path中必须有v2，没有的话会报错) PS： v2.x以上的其他版本都一样，path必须以大版本好结束，如github.com/micro/go-micro/v3 v3.0.0","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"}]},{"title":"gitlab-runner config for docker runner","date":"2020-11-02T03:14:04.000Z","path":"2020/11/02/gitlab-runner-config-for-docker-runner/","text":"在gitlab使用gitlab runner执行CI/CD时，发现每次都要重新拉取docker镜像，即使本地已经有了，也不使用，直接重新拉去，导致流程很慢， 查询了下对应的配置文档，修改配置参数pull_policy为pull_policy = &quot;if-not-present&quot;，优先使用本地镜像。 配置文件位置 root用户 /etc/gitlab-runner/config.toml 非root用户 ~/.gitlab-runner/config.toml 以前是在*nix系统上的，其他系统./config.toml 配置项配置项是在runners 下的 runners.docker下的pull_policy， 如果没有，自己手动添加后，设置值为&quot;if-not-present&quot; PS:大部分配置的修改，可以不用重启（不包含listen_address），runner会没5分钟检查一次文件 官方文档所有的配置以及对应的作用可以参考下面的官方文档： https://docs.gitlab.com/runner/configuration/advanced-configuration.html","comments":true,"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://ioridy.github.io/tags/gitlab/"},{"name":"gitlab-runner","slug":"gitlab-runner","permalink":"http://ioridy.github.io/tags/gitlab-runner/"},{"name":"docker","slug":"docker","permalink":"http://ioridy.github.io/tags/docker/"}]},{"title":"go-micro api version","date":"2020-07-27T14:45:10.000Z","path":"2020/07/27/go-micro-api-version/","text":"go-micro的api版本机制看example的时候感觉很简单，但是实际要是用的时候，还是有好几个点费了不少时间，最终通过扒code弄的差不多了，这里记录下。 go-micro可以提供同时提供http和grpc的访问，如果不是用自定义的EndPoint时，这两种的api版本控制没有区别，下面分别说下这几种情况下的版本控制机制。 grpcgrpc的访问主要是通过protobuf文件生成的对应语言的文件来访问，所以版本控制是通过protobuf中的package定义来控制的，只需要在package的定义中加入版本信息即可，比如： 123456//v1package go.micro.api.v1.test;//v2package go.micro.api.v2.test; 这里我理解只要package定义不一样，可以区别出具体的服务即可，v1和v2主要是语义上好理解 版本号建议加载api之后，这样可以保持和http访问时的一致（go-micro api gateway可自动转换grpc到http，下边会详细说） httpgo-micro的http访问主要是通过micro的api网关实现的，目前有两种形式： /[service]/[method]http的url按照上面的规则解析，动态转化为rpc的访问，以上面的package定义为例 12345678910//v1package go.micro.api.v1.test;//url v1/test/hello//v2package go.micro.api.v2.test;//url v2/test/hello// hello func defined 下面还有几个url解析的官方example更明了一点 Path Service Method /foo/bar go.micro.api.foo Foo.Bar /foo/bar/baz go.micro.api.foo Bar.Baz /foo/bar/baz/cat go.micro.api.foo.bar Baz.Cat Versioned API URLs can easily be mapped to service names: Path Service Method /foo/bar go.micro.api.foo Foo.Bar /v1/foo/bar go.micro.api.v1.foo Foo.Bar /v1/foo/bar/baz go.micro.api.v1.foo Bar.Baz /v2/foo/bar go.micro.api.v2.foo Foo.Bar /v2/foo/bar/baz go.micro.api.v2.foo Bar.Baz code中的实现逻辑是： 分割url为数组 根据数组的长度来构建service和method 少于等于2，第一个作为service，整体作为method 1234567 // If we&#x27;ve got two or less parts// Use first part as service// Use all parts as methodif len(parts) &lt;= 2 &#123; name := parts[0] return name, methodName(parts)&#125; 等于3，前面2个作为service，后边2个为method 12345 // Treat /v[0-9]+ as versioning where we have 3 parts// /v1/foo/bar =&gt; service: v1.foo method: Foo.barif len(parts) == 3 &amp;&amp; versionRe.Match([]byte(parts[0])) &#123; name := strings.Join(parts[:len(parts)-1], &quot;.&quot;) r 大于3，最后两个作为method，其余所有作为service 1234 // Service is everything minus last two parts// Method is the last two partsname := strings.Join(parts[:len(parts)-2], &quot;.&quot;)return name, methodName(parts[len(parts)-2:]) EndPointendpoint是上面不同的是，因为url是自己定义的，所以上面的方式解析出来的结果是错误的，所以必须在用url比对路由的地址的时候，就成功，否则就会报错 我这边想到的版本就是在设置EndPoint的时候加入版本号（客户端请求会带版本后，为了在比对的时候保持一致来保证成功找到注册的EndPoint），找到endpoint之后的流程就相同了，这里不过多描述。 之后我会在专门写一篇文章，从code追踪下整个url的解析过程，就会清楚为什么需要保证url一致，比对成功 1234567891011121314func registerUser(server server.Server) error &#123; return pb.RegisterUserHandler(server, new(Handler), mApi.WithEndpoint(&amp;mApi.Endpoint&#123; // The RPC method Name: &quot;User.Register&quot;, // The HTTP paths. This can be a POSIX regex Path: []string&#123;&quot;^v1/user/register$&quot;&#125;, // The HTTP Methods for this endpoint Method: []string&#123;&quot;POST&quot;&#125;, // The API handler to use Handler: rpc.Handler, &#125;), )&#125; 这里的版本号需要和**protobuf文件中的package定义的一致，否则还是服务找到对应的服务（上边提到了version添加的位置），因为最终还是需要通过rpc来访问具体的服务的。 其他这里还有个问题，就是在main中，初始化micro服务的时候，设置的version到目前为止都没有用到，我好奇搜索了下version关键字，有发现client/selector/filter.go中有对应version的使用，看位置应该是client用来过滤服务的，不过没细看，留个坑，之后来填。","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"http://ioridy.github.io/tags/go-micro/"},{"name":"micro","slug":"micro","permalink":"http://ioridy.github.io/tags/micro/"},{"name":"version","slug":"version","permalink":"http://ioridy.github.io/tags/version/"}]},{"title":"windows10自带我的文档等路径修改","date":"2020-07-27T09:58:39.000Z","path":"2020/07/27/windows10自带我的文档等路径修改/","text":"在重装了Windows10后，习惯修改用户相关的文件夹路径到非C盘时，不知道什么原因导致我的文档和下载两个快捷方式都指向了一个文件夹，之后尝试了修改，全删除重新设置等都不行，最终是通过注册表修改恢复的，记录下方法。 指系统自带的：我的文档、图片、音乐、下载、视频、桌面等文件夹 常规修改路径的方法常规的修改方法就是在文件夹上右键-&gt;属性-&gt;位置-&gt;移动即可 出错后修正方法出错后的修改办法（无法通过正常属性的办法修改），都可以使用此方法尝试还原或直接修改。 系统自带的相关文件夹的路径都记录在注册表中，只需要找到需要修改的项，修改对应值即可，具体路径如下： 1HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders 上面的路径中有些项存在名称和ID两种配置，名称的是系统的默认配置，ID的是当前应用的设置（我自己推导的，不一定正确） 具体ID对应的名称如下： 1234567&#123;F42EE2D3-909F-4907-8871-4C22FC0BF756&#125; Document&#123;A0C69A99-21C8-4671-8703-7934162FCF1D&#125; Music&#123;7d83ee9b-2244-4e70-b1f5-5393042af1e4&#125; Downloads&#123;374DE290-123F-4565-9164-39C4925E467B&#125; Downloads&#123;754AC886-DF64-4CBA-86B5-F7FBF4FBCEF5&#125; Desktop&#123;35286A68-3C57-41A1-BBB1-0EAE73D76C95&#125; Videos&#123;0DDD015D-B06C-45D5-8C4C-F59713854639&#125; Pictures 如果你要修改的项没包含在里面，可以通过下面的注册表地址来查找ID对应的名称： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions 最后配上截图说明 属性修改路径 注册表路径修改 注册表文件夹ID对应的描述查询","comments":true,"tags":[{"name":"Windows","slug":"Windows","permalink":"http://ioridy.github.io/tags/Windows/"}]},{"title":"go-micro中的发布订阅Broker分析","date":"2020-07-09T07:38:33.000Z","path":"2020/07/09/go-micro中的发布订阅Broker分析/","text":"最近手上有点时间，打算继续了解下go-micro的发布订阅（消息），看了micro的examples “micro examples”)后，有个疑问，go-micro在提供发布订阅的插件Broker（以及几种实现）的同时，go-micro本身还实现了Publish（Client）以及Subscribe（Server）功能,于是翻了下源码，做个记录。 BrokerBroker是go-micro定义的一个异步消息的接口，同时使用插件的形式，可随意在不同的实现（http，nats,rabbitmq）之间无缝切换。 1234567891011// Broker is an interface used for asynchronous messaging.type Broker interface &#123; Init(...Option) error Options() Options Address() string Connect() error Disconnect() error Publish(topic string, m *Message, opts ...PublishOption) error Subscribe(topic string, h Handler, opts ...SubscribeOption) (Subscriber, error) String() string&#125; 从上面的接口可以看出，使用Broker来完成发布订阅只需要以下几步： 初始化一个Broker(Init) 连接Broker(Connect) 使用准备好的Broker发布/订阅(Publish/Subscribe) 关闭Broker(Disconnect) go-micro中默认的broker实现go-micro默认有基于http的Broker实现，可以直接使用。micro有给出具体的example “broker example”)，具体看下source code中的实现。 下面是go-micro中broer.go中对DefaultBroker的相关code: 12345678910111213141516171819202122232425262728var ( DefaultBroker Broker = NewBroker())func Init(opts ...Option) error &#123; return DefaultBroker.Init(opts...)&#125;func Connect() error &#123; return DefaultBroker.Connect()&#125;func Disconnect() error &#123; return DefaultBroker.Disconnect()&#125;func Publish(topic string, msg *Message, opts ...PublishOption) error &#123; return DefaultBroker.Publish(topic, msg, opts...)&#125;func Subscribe(topic string, handler Handler, opts ...SubscribeOption) (Subscriber, error) &#123; return DefaultBroker.Subscribe(topic, handler, opts...)&#125;func String() string &#123; return DefaultBroker.String()&#125; 可以看到都是基于NewBroker()返回的broker实例来做的公用方法封装，我们进一步看看。 1234// NewBroker returns a new http brokerfunc NewBroker(opts ...Option) Broker &#123; return newHttpBroker(opts...)&#125; 这里是直接返回了一个http实现的broker(和上面提到的默认是基于http实现的匹配)，继续跟newHttpBroker。 这里这列出部分code，详细的可直接参考go-micro下的http.go 1234567891011h := &amp;httpBroker&#123; id: uuid.New().String(), address: addr, opts: options, r: options.Registry, c: &amp;http.Client&#123;Transport: newTransport(options.TLSConfig)&#125;, subscribers: make(map[string][]*httpSubscriber), exit: make(chan chan error), mux: http.NewServeMux(), inbox: make(map[string][][]byte), &#125; 这里的核心是new了一个httpBroker，做为Broker接口的实现，在具体的实现就不在这里说了，下来我们看看上面提到接口的实现。 Init12345678910111213141516171819202122232425262728293031323334353637func (h *httpBroker) Init(opts ...Option) error &#123; h.RLock() if h.running &#123; h.RUnlock() return errors.New(&quot;cannot init while connected&quot;) &#125; h.RUnlock() h.Lock() defer h.Unlock() for _, o := range opts &#123; o(&amp;h.opts) &#125; if len(h.opts.Addrs) &gt; 0 &amp;&amp; len(h.opts.Addrs[0]) &gt; 0 &#123; h.address = h.opts.Addrs[0] &#125; if len(h.id) == 0 &#123; h.id = &quot;go.micro.http.broker-&quot; + uuid.New().String() &#125; // get registry reg := h.opts.Registry if reg == nil &#123; reg = registry.DefaultRegistry &#125; // get cache if rc, ok := h.r.(cache.Cache); ok &#123; rc.Stop() &#125; // set registry h.r = cache.New(reg) // reconfigure tls config if c := h.opts.TLSConfig; c != nil &#123; h.c = &amp;http.Client&#123; Transport: newTransport(c), &#125; &#125; return nil&#125; 从上面的code中可以看到，Init的作用就是初始化各种配置，如果Option参数有提供，就是用参数提供的，如果没有就在这里设置一个，这里有2个点我们需要额外关注下： Registry Registry是注册中心，如果option中没有提供registry，就会使用go-micro默认实现的（msdn） TLSConfig TLSConfig是针对https的配置，默认是http Connect1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677func (h *httpBroker) Connect() error &#123; h.RLock() if h.running &#123; h.RUnlock() return nil &#125; h.RUnlock() h.Lock() defer h.Unlock() var l net.Listener var err error if h.opts.Secure || h.opts.TLSConfig != nil &#123; config := h.opts.TLSConfig fn := func(addr string) (net.Listener, error) &#123; if config == nil &#123; hosts := []string&#123;addr&#125; // check if its a valid host:port if host, _, err := net.SplitHostPort(addr); err == nil &#123; if len(host) == 0 &#123; hosts = maddr.IPs() &#125; else &#123; hosts = []string&#123;host&#125; &#125; &#125; // generate a certificate cert, err := mls.Certificate(hosts...) if err != nil &#123; return nil, err &#125; config = &amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cert&#125;&#125; &#125; return tls.Listen(&quot;tcp&quot;, addr, config) &#125; l, err = mnet.Listen(h.address, fn) &#125; else &#123; fn := func(addr string) (net.Listener, error) &#123; return net.Listen(&quot;tcp&quot;, addr) &#125; l, err = mnet.Listen(h.address, fn) &#125; if err != nil &#123; return err &#125; addr := h.address h.address = l.Addr().String() go http.Serve(l, h.mux) go func() &#123; h.run(l) h.Lock() h.opts.Addrs = []string&#123;addr&#125; h.address = addr h.Unlock() &#125;() // get registry reg := h.opts.Registry if reg == nil &#123; reg = registry.DefaultRegistry &#125; // set cache h.r = cache.New(reg) // set running h.running = true return nil&#125; Connect方法的主要作用是创建一个Htto Server用来接收Publish时发送的消息 Subscribe123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263func (h *httpBroker) Subscribe(topic string, handler Handler, opts ...SubscribeOption) (Subscriber, error) &#123; var err error var host, port string options := NewSubscribeOptions(opts...) // parse address for host, port host, port, err = net.SplitHostPort(h.Address()) if err != nil &#123; return nil, err &#125; addr, err := maddr.Extract(host) if err != nil &#123; return nil, err &#125; var secure bool if h.opts.Secure || h.opts.TLSConfig != nil &#123; secure = true &#125; // register service node := &amp;registry.Node&#123; Id: topic + &quot;-&quot; + h.id, Address: mnet.HostPort(addr, port), Metadata: map[string]string&#123; &quot;secure&quot;: fmt.Sprintf(&quot;%t&quot;, secure), &quot;broker&quot;: &quot;http&quot;, &quot;topic&quot;: topic, &#125;, &#125; // check for queue group or broadcast queue version := options.Queue if len(version) == 0 &#123; version = broadcastVersion &#125; service := &amp;registry.Service&#123; Name: serviceName, Version: version, Nodes: []*registry.Node&#123;node&#125;, &#125; // generate subscriber subscriber := &amp;httpSubscriber&#123; opts: options, hb: h, id: node.Id, topic: topic, fn: handler, svc: service, &#125; // subscribe now if err := h.subscribe(subscriber); err != nil &#123; return nil, err &#125; // return the subscriber return subscriber, nil&#125; 这部分代码的核心功能就是创建用于订阅的server，一个topic创建一个server并收集（注册）到httpSubscriber的svc列表中（发布消息时使用topic在subscriber的svc列表中查询到对应的server给他发送消息）。 Publish123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125func (h *httpBroker) Publish(topic string, msg *Message, opts ...PublishOption) error &#123; // create the message first m := &amp;Message&#123; Header: make(map[string]string), Body: msg.Body, &#125; for k, v := range msg.Header &#123; m.Header[k] = v &#125; m.Header[&quot;Micro-Topic&quot;] = topic // encode the message b, err := h.opts.Codec.Marshal(m) if err != nil &#123; return err &#125; // save the message h.saveMessage(topic, b) // now attempt to get the service h.RLock() s, err := h.r.GetService(serviceName) if err != nil &#123; h.RUnlock() return err &#125; h.RUnlock() pub := func(node *registry.Node, t string, b []byte) error &#123; scheme := &quot;http&quot; // check if secure is added in metadata if node.Metadata[&quot;secure&quot;] == &quot;true&quot; &#123; scheme = &quot;https&quot; &#125; vals := url.Values&#123;&#125; vals.Add(&quot;id&quot;, node.Id) uri := fmt.Sprintf(&quot;%s://%s%s?%s&quot;, scheme, node.Address, DefaultPath, vals.Encode ()) r, err := h.c.Post(uri, &quot;application/json&quot;, bytes.NewReader(b)) if err != nil &#123; return err &#125; // discard response body io.Copy(ioutil.Discard, r.Body) r.Body.Close() return nil &#125; srv := func(s []*registry.Service, b []byte) &#123; for _, service := range s &#123; var nodes []*registry.Node for _, node := range service.Nodes &#123; // only use nodes tagged with broker http if node.Metadata[&quot;broker&quot;] != &quot;http&quot; &#123; continue &#125; // look for nodes for the topic if node.Metadata[&quot;topic&quot;] != topic &#123; continue &#125; nodes = append(nodes, node) &#125; // only process if we have nodes if len(nodes) == 0 &#123; continue &#125; switch service.Version &#123; // broadcast version means broadcast to all nodes case broadcastVersion: var success bool // publish to all nodes for _, node := range nodes &#123; // publish async if err := pub(node, topic, b); err == nil &#123; success = true &#125; &#125; // save if it failed to publish at least once if !success &#123; h.saveMessage(topic, b) &#125; default: // select node to publish to node := nodes[rand.Int()%len(nodes)] // publish async to one node if err := pub(node, topic, b); err != nil &#123; // if failed save it h.saveMessage(topic, b) &#125; &#125; &#125; &#125; // do the rest async go func() &#123; // get a third of the backlog messages := h.getMessage(topic, 8) delay := (len(messages) &gt; 1) // publish all the messages for _, msg := range messages &#123; // serialize here srv(s, msg) // sending a backlog of messages if delay &#123; time.Sleep(time.Millisecond * 100) &#125; &#125; &#125;() return nil 看过了上面的Subscribe实现，这里的Publish就比较简单 创建消息体并存储在inbox 根据topic以及broker的标签(这里是固定http)来查找订阅的server（在上面订阅模块创建的） 上面有可能会查找出多个node(订阅server)，所以里面还有一个版本的机制，如果指定了版本就会给所有的匹配节点发送（默认是随机发送一个） 使用http post的方式（异步）把消息发送出去 Disconnect1234567891011121314151617181920212223242526func (h *httpBroker) Disconnect() error &#123; h.RLock() if !h.running &#123; h.RUnlock() return nil &#125; h.RUnlock() h.Lock() defer h.Unlock() // stop cache rc, ok := h.r.(cache.Cache) if ok &#123; rc.Stop() &#125; // exit and return err ch := make(chan error) h.exit &lt;- ch err := &lt;-ch // set not running h.running = false return err&#125; 这部分功能很简单，清空缓存并发送退出的消息，同时停止服务 以上就是go-micro中默认基于http的broker实现。 go-micro中对于broker的包装在看完broker的http默认实现后，我们对于broker有了一个大体了解，接下来我们在看下go-micro对于broker做的包装部分，应该是为了简化使用（确实只需要一步就可以）。 订阅RegisterSubscriber： 123456789101112131415161718func main() &#123; // create a service service := micro.NewService( micro.Name(&quot;go.micro.srv.pubsub&quot;), ) // parse command line service.Init() // register subscriber micro.RegisterSubscriber(&quot;example.topic.pubsub.1&quot;, service.Server(), new(Sub)) // register subscriber with queue, each message is delivered to a unique subscriber micro.RegisterSubscriber(&quot;example.topic.pubsub.2&quot;, service.Server(), subEv, server.SubscriberQueue(&quot;queue.pubsub&quot;)) if err := service.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 发布NewPublisher, Publish： 1234567891011121314151617181920func main() &#123; // create a service service := micro.NewService( micro.Name(&quot;go.micro.cli.pubsub&quot;), ) // parse command line service.Init() // create publisher pub1 := micro.NewPublisher(&quot;example.topic.pubsub.1&quot;, service.Client()) pub2 := micro.NewPublisher(&quot;example.topic.pubsub.2&quot;, service.Client()) // pub to topic 1 go sendEv(&quot;example.topic.pubsub.1&quot;, pub1) // pub to topic 2 go sendEv(&quot;example.topic.pubsub.2&quot;, pub2) // block forever select &#123;&#125;&#125; 以上只是代码节选，具体使用方法可以参考example中的pubsub。 Subscriber订阅对比直接用Broker只需要一步RegisterSubscriber,我们看看里面实现 123456789101112131415161718192021222324252627282930313233343536373839//go-micro/micro.go// RegisterSubscriber is syntactic sugar for registering a subscriberfunc RegisterSubscriber(topic string, s server.Server, h interface&#123;&#125;, opts ...server.SubscriberOption) error &#123; return s.Subscribe(s.NewSubscriber(topic, h, opts...))&#125;//go-micro/server/rpc_server.gofunc (s *rpcServer) NewSubscriber(topic string, sb interface&#123;&#125;, opts ...SubscriberOption) Subscriber &#123; return s.router.NewSubscriber(topic, sb, opts...)&#125;func (s *rpcServer) Subscribe(sb Subscriber) error &#123; s.Lock() defer s.Unlock() if err := s.router.Subscribe(sb); err != nil &#123; return err &#125; s.subscribers[sb] = nil return nil&#125;//go-micro/server/rpc_router.go// router represents an RPC router.type router struct &#123; ....... subscribers map[string][]*subscriber&#125;//go-micro/server/subscriber.gotype subscriber struct &#123; topic string rcvr reflect.Value typ reflect.Type subscriber interface&#123;&#125; handlers []*handler endpoints []*registry.Endpoint opts SubscriberOptions&#125; 上面的节选code可以看出，在默认server(rpcServer)中的router中定义了个map类型的变量subscribers用来存储订阅的topic和对应处理的subscriber,server在接收到消息后，只需要根据topic去map中找到subscriber，去处理即可。 subscriber中具体的处理，可以从定义中看出来，里面存储对应路由和响应的handler（server本身的功能），有兴趣可以在go-micro/server/subscriber.go看看具体代码实现。 Publisher发布是在go-micro的默认client实现（rpc_client）里面定义了一个默认的broker(上面有分析过的http实现) 12345678910111213141516171819202122232425//go-micro/micro.go// Deprecated: NewPublisher returns a new Publisherfunc NewPublisher(topic string, c client.Client) Event &#123; return NewEvent(topic, c)&#125;// NewEvent creates a new event publisherfunc NewEvent(topic string, c client.Client) Event &#123; if c == nil &#123; c = client.NewClient() &#125; return &amp;event&#123;c, topic&#125;&#125;//go-micro/event.gotype event struct &#123; c client.Client topic string&#125;func (e *event) Publish(ctx context.Context, msg interface&#123;&#125;, opts ...client.PublishOption) error &#123; return e.c.Publish(ctx, e.c.NewMessage(e.topic, msg), opts...)&#125; 这里可以看到实际上是使用传递进来的client来初始化一个event，并用来发送消息，如果传递的是空，默认创建一个client（rpcClient）。 总结经过以上过程的追踪，最终总结下来就几点： broker定义了接口，micro提供的插件的形式可无缝替换实现 go-micro提供了一个默认的broker实现，是基于http go-micro的基于默认的server、client以及brkoer包装了一套更简单的pub和sub方法","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"http://ioridy.github.io/tags/go-micro/"},{"name":"micro","slug":"micro","permalink":"http://ioridy.github.io/tags/micro/"},{"name":"broker","slug":"broker","permalink":"http://ioridy.github.io/tags/broker/"}]},{"title":"Sketchup快捷键设置存储位置","date":"2020-07-07T16:00:00.000Z","path":"2020/07/08/Sketchup-short-cut/","text":"想要通过程序修改Sketchup的快捷键，API文档没有提供对应的接口，利用从Sketchup快捷键值的存储直接修改实现了，因为2018以及之后的版本快捷键存储位置修改了，做个记录。 Sketchup2018以及之后的版本2018以及以后的版本快捷键以及相关的设置都存储在当前用户的appdata目录下，具体路径如下： 1C:\\Users\\当前用户\\AppData\\Roaming\\SketchUp\\SketchUp 2020\\SketchUp\\SharedPreferences.json 请根据当前用户以及Sketchup替换对应的部分 Sketchup2017的版本2017版本（17之前的版本没用过）快捷键以及相关的设置都存储在注册表中，具体路径如下： 1计算机\\HKEY_CURRENT_USER\\SOFTWARE\\SketchUp\\SketchUp 2017\\Settings 最后附上两张截图Sketchup2020 Sketchup217","comments":true,"tags":[{"name":"Sketchup","slug":"Sketchup","permalink":"http://ioridy.github.io/tags/Sketchup/"}]},{"title":"grpc使用时关于protobuf中引用其他文件时生成路径问题","date":"2020-04-06T14:42:17.000Z","path":"2020/04/06/grpc使用时关于protobuf中引用其他文件时生成路径问题/","text":"记录下，当protobuf中引用其他文件时，经常因为路径不对无法生成成功的问题。 protobuf中引用其他pb文件protobuf文件的引用是通过import关键字来的，需要写对路径，以下是我在golang中使用的sample 123456789syntax = &quot;proto3&quot;;import &quot;google/protobuf/empty.proto&quot;; //google提供的，具体文件在GOPATH下import &quot;common/proto/common/common.proto&quot;; //我自己定义，在同一个package下service Captcha &#123; rpc GenerateCaptcha(.google.protobuf.Empty) returns (CaptchaInfoResponse) &#123;&#125; rpc VerifyCaptcha(CaptchaInfo) returns (EmptyResponse) &#123;&#125;&#125; 生成时的路径设置以下是我上面提供的sample文件的生成命令 1protoc --proto_path=.:$GOPATH/src:../ --go_out=. --micro_out=. proto/captcha/captcha.proto 这里面的核心是proto_path,用来指定你引用的proto文件所在的目录，只有指定正确才能正常生成， proto_path(可以用I来替换)指定了三个目录，中间用:来分割（也可以分开，用三个proto_path来指定） 123. #当前目录，用来指定需要生成的文件工作目录proto/captcha/captcha.proto$GOPATH/src # google包所在的目录google/protobuf/empty.proto../ # 相对路径，用来指定common.proto所在的目录 需要注意下，这里指定的目录是到protobuf文件中import路径的父路径（即这里的路径+pb中import的文件路径就是全路径） 我具体的代码目录，可以参考下 问题golang中通过go get安装的包都在$GOPATH的pkg下面，而且文件目录会在版本号，和protobuf文件中的路径不相符，我暂时不知道处理办法，是通过手动clone下来避过去的","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"grpc","slug":"grpc","permalink":"http://ioridy.github.io/tags/grpc/"},{"name":"protobuf","slug":"protobuf","permalink":"http://ioridy.github.io/tags/protobuf/"}]},{"title":"image to base64 in golang","date":"2020-04-04T10:05:58.000Z","path":"2020/04/04/image-to-base64-in-golang/","text":"新入坑golang，要做个图形验证码，记录下获得image数据后怎么转成base64的格式 image-&gt;base64具体实现如下面代码： 123456emptyBuff := bytes.NewBuffer(nil) //开辟一个新的空buffjpeg.Encode(emptyBuff, img, nil) //img写入到buffdist := make([]byte, 50000) //开辟存储空间base64.StdEncoding.Encode(dist, emptyBuff.Bytes()) //buff转成base64index := bytes.IndexByte(dist, 0) //这里要注意，因为申请的固定长度数组，所以没有被填充完的部分需要去掉，负责输出可能出错baseImage := dist[0:index] 上面代码最后一行 baseImage 是为了剔除为0值的多余部分 []byte-&gt;string具体实现如下面代码： 1*(*string)(unsafe.Pointer(&amp;baseImage)) []byte转string可以通过强制类型转换，但是效率不高， 可以通过指针的形式来提高效率","comments":true,"tags":[{"name":"golang","slug":"golang","permalink":"http://ioridy.github.io/tags/golang/"},{"name":"base64","slug":"base64","permalink":"http://ioridy.github.io/tags/base64/"},{"name":"image","slug":"image","permalink":"http://ioridy.github.io/tags/image/"}]},{"title":"VS Code中markdown转pdf或者图片","date":"2020-02-03T12:38:00.000Z","path":"2020/02/03/vs-code-markdown-convert-pdf/","text":"Markdown的编辑器有很多，但是我为了方便切避免按照过多的app，就在VS Code里面装了Markdown PDF来支持markdown的编写。 插件安装搜索插件Markdown PDF然后安装 转pdf或者图片在VS Code打开的markdown文件上面右键菜单，选择需要转换的格式，等待提示完成即可。 转换的文件会markdown所在的当前目录 备注问题Markdown PDF安装完成后，会自动下载安装Chromium，如果下载慢或者下载失败的话，可以通过手动指定Chrome浏览器的路径来解决。 下面实例是我macOS的配置，请自行修改后面的路径为你当前体用Chrome的路径 1&quot;markdown-pdf.executablePath&quot;: &quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot; 状态栏Chromium安装提示","comments":true,"tags":[{"name":"vs code","slug":"vs-code","permalink":"http://ioridy.github.io/tags/vs-code/"},{"name":"markdown","slug":"markdown","permalink":"http://ioridy.github.io/tags/markdown/"}]},{"title":"WindowsTerminal右键菜单","date":"2020-01-02T16:00:00.000Z","path":"2020/01/03/WindowsTerminal右键菜单/","text":"最近捣鼓了Windows Terminal后，使用起来还不错，我使用的是从windows app store安装的办法，右键菜单没有在当前目录打开的菜单，自己尝试加搜索后搞定，记录下方法： 右键菜单添加通过Windows Terminal打开项 键盘按Win键+R键输入“regedit”打开注册表 打开路径HKEY_CLASSES_ROOT\\Directory\\Background\\shell 点击shell，右键在shell项下面建立新项Open Windows Terminal，然后再在“Open Windows Terminal”项下面建立新项command 点击command，双击右边的默认，在数值里面输入 &quot;%LOCALAPPDATA%\\Microsoft\\WindowsApps\\wt.exe&quot; ，确定关闭注册表就可以了 以上是主要设置，下面是可选设置： 点击“Open Windows Terminal”项（之前创建的项，自己命名的名称） 名称编辑默认，修改值为想显示的名称 图标右键“新建-&gt;字符串值”，名称Icon, 值：需要设置的ico文件路径 Windows Terminal的ico文件可以在github上搜索terminal.ico就可以 设置Windows Terminal打开后默认在当前文件夹 在Windows Terminal的设置中，修改 startingDirectory&quot; : null项（如果没有新增即可） 默认是打开system32目录，如果不修改，不管什么方法打开都是system32目录","comments":true,"tags":[{"name":"Windows","slug":"Windows","permalink":"http://ioridy.github.io/tags/Windows/"}]},{"title":"jenkins中文乱码","date":"2019-12-04T16:00:00.000Z","path":"2019/12/05/jenkins中文乱码/","text":"工作中推进Jenkins遇到Console Output的输出中，有中文显示乱码的情况，网上查了资料做了几种尝试，发现乱码出现的源头不一样，解决的办法不一样，这里记录下自己的目前尝试的结论： Execute Windows batch command 输出中文显示乱码 环境变量中添加对应的设置项 12变量名：JAVA_TOOL_OPTIONS变量值：-Difile.encoding=utf-8 python 脚本输出中文显示乱码 环境变量中添加对应的设置项 12变量名：PYTHONIOENCODING变量值：UTF8 以上主要是针对Jenlins中执行命令或脚本输出的乱码,修改完成后需要重启Jenkins服务生效","comments":true,"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://ioridy.github.io/tags/Jenkins/"}]},{"title":".net core异常全局处理","date":"2017-08-10T15:03:30.000Z","path":"2017/08/10/net-core异常全局处理/","text":"最近在项目中使用.net core开发server端API，每个action中都需要同样的code来处理系统内部异常和自定义的异常错误，于是想把这部分提出来，统一处理下，最先想到的就是使用Middleware，简单试了下，效果不错。 1. 先定义异常处理中间件 按照微软中间件的写法，在处理请求出添加try catch结构，并在catch中进行你需要的处理，具体如下： 1234567891011121314151617181920212223public class ExceptionMiddleware&#123; private readonly RequestDelegate _next; public ExceptionMiddleware(RequestDelegate next) &#123; _next = next; &#125; public async Task Invoke(HttpContext context) &#123; try &#123; await _next(context); &#125; catch (Exception e) &#123; context.Response.ContentType = &quot;application/json&quot;; context.Response.StatusCode = (int)HttpStatusCode.InternalServerError; await context.Response.WriteAsync(JsonConvert.SerializeObject(new &#123; ErrorMessage = e.Message &#125;)); &#125; &#125;&#125; 此处为纯Web Api的异常处理方法，\bcatch后直接返回json对象，MVC可以catch后跳转到固定的错误页面。 2. Startup中注册异常处理中间件 定义好异常处理类，需要在Startup中进行注册声明，这样请求才会经过自己定义的异常处理中间件，code如下： 12345678910public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)&#123; loggerFactory.AddConsole(Configuration.GetSection(&quot;Logging&quot;)); loggerFactory.AddDebug(); // add My Exception handle class:ExceptionMiddleware app.UseMiddleware&lt;ExceptionMiddleware&gt;(); app.UseMvc();&#125; 注册时，需要注意注册顺序，异常处理中间件一般在第一个注册","comments":true,"tags":[{"name":".net core","slug":"net-core","permalink":"http://ioridy.github.io/tags/net-core/"},{"name":"异常处理","slug":"异常处理","permalink":"http://ioridy.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"Execption","slug":"Execption","permalink":"http://ioridy.github.io/tags/Execption/"}]},{"title":"Git忽略文件.gitignore","date":"2017-03-06T14:59:46.000Z","path":"2017/03/06/Git忽略文件-gitignore/","text":"开始在工作中使用git后，还是与到了好多实际问题，比如想忽略默认文件（文件夹），但是网上搜索后，按照描述添加了.gitignore文件，但是没有生效，继续搜索找到原因如下：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 1234git rm -r --cached .git add .git commit -m &#x27;update .gitignore&#x27; .gitignore 文件的用途，该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。如果文件曾经被 Git 记录过，那么.gitignore 就对它们完全无效 顺便记录下，.gitignore文件还可以指定要将哪些文件添加到版本管理中： 123!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。 原文链接：http://www.cnblogs.com/kevingrace/p/5690241.html","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"http://ioridy.github.io/tags/Git/"}]},{"title":"Bonobo Git记住密码","date":"2017-03-02T06:56:32.000Z","path":"2017/03/02/Bonobo-Git记住密码/","text":"在服务器部署时想利用php执行git命令自动部署，所以需要记住密码方便命令行执行，通过搜索找到解决方法，做个记录（原文链接）. Bonobo Git Server是基于HTTP或者HTTPS协议的，与客户端采用的是basic authentication方式来做认证的。这种认证方式允许用户把用户名和密码当做URL的一部分来建立链接。所以要记住密码只需要在客户端运行git时，只需要用以下方式运行git命令即可（请自行替换其中的username，password以及server地址）: git clone http://username:password@myserver.com/bonobo-git-repository.git 如果已经clone了source到本地，就需要修改远程分支地址的URL，运行如下命令: git remote set-url origin http://username:@myserver.com/bonobo-git-repository.git/ 接下来就可以利用git命令去测试下效果了！ 在使用git remote 时，请先使用git remote -v确认分支情况。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"http://ioridy.github.io/tags/Git/"},{"name":"Bonobo","slug":"Bonobo","permalink":"http://ioridy.github.io/tags/Bonobo/"}]},{"title":"H5移动端网页输入法弹出时页面不自动滚动","date":"2016-11-06T14:37:17.000Z","path":"2016/11/06/input-and-textarea-blcok-by-input-method-on-mobile-H5/","text":"手机网页开发中，遇到点击输入框(input,textarea)时，输入法弹出但页面不自动向上滚动，搜索发现微信的UI框架weui中的解决办法：123456789101112131415// .container 设置了 overflow 属性, 导致 Android 手机下输入框获取焦点时, 输入法挡住输入框的 bug// 相关 issue: https://github.com/weui/weui/issues/15// 解决方法:// 0. .container 去掉 overflow 属性, 但此 demo 下会引发别的问题// 1. 参考 http://stackoverflow.com/questions/23757345/android-does-not-correctly-scroll-on-input-focus-if-not-body-element// Android 手机下, input 或 textarea 元素聚焦时, 主动滚一把if (/Android/gi.test(navigator.userAgent)) &#123; window.addEventListener(&#x27;resize&#x27;, function () &#123; if (document.activeElement.tagName == &#x27;INPUT&#x27; || document.activeElement.tagName == &#x27;TEXTAREA&#x27;) &#123; window.setTimeout(function () &#123; document.activeElement.scrollIntoViewIfNeeded(); &#125;, 0); &#125; &#125;)&#125; weui地址：http://weui.github.io/weui/example.js 备注：目前我只在Android下测试发现此问题，网上有提到iOS手机使用默认输入法时是OK的，但是使用第三方的输入法可能会存在问题，暂时没有解决办法！","comments":true,"tags":[{"name":"Mobile","slug":"Mobile","permalink":"http://ioridy.github.io/tags/Mobile/"},{"name":"H5","slug":"H5","permalink":"http://ioridy.github.io/tags/H5/"}]},{"title":"Ali Oss JS SDK问题记录","date":"2016-10-06T02:41:29.000Z","path":"2016/10/06/Ali-Oss-JS-SDK/","text":"最近在用阿里的OSS存储，在做网页端上传下载时用的JS SDK，遇到问题记录下 1. then is not a functionJS sdk按照阿里的文档sample写的上传的部分代码，出现then的错误(如下图1)，后在网上查找到解决办法： 12345678//调用OSS.Wrapper构造函数var client = new OSS.Wrapper(&#123; region: &#x27;oss-cn-beijing&#x27;, accessKeyId: &#x27;accessKeyId&#x27;, accessKeySecret: &#x27;accessKeySecret&#x27;, stsToken: &#x27;securityToken&#x27;, bucket: &#x27;bucketName&#x27; &#125;); 参考链接：https://www.v2ex.com/t/271117","comments":true,"tags":[{"name":"OSS","slug":"OSS","permalink":"http://ioridy.github.io/tags/OSS/"}]},{"title":"ASP部署到服务器错误","date":"2016-08-31T05:38:32.000Z","path":"2016/08/31/ASP部署到服务器错误/","text":"ASP.NET在本地都OK，但是部署到服务器上出现如下错误信息，搜索了下解决方案，记录下： 错误信息：配置错误 不能在此路径中使用此配置节。如果在父级别上锁定了该节，便会出现这种情况。锁定是默认设置的(overrideModeDefault=”Deny”)，或者是通过包含 overrideMode=”Deny” 或旧有的 allowOverride=”false” 的位置标记明确设置的。 解决办法：出现这个错误是因为 IIS 7 采用了更安全的 web.config 管理机制，默认情况下会锁住配置项不允许更改。要取消锁定可以以管理员身份运行命令行 %windir%\\system32\\inetsrv\\appcmd unlock config -section:system.webServer/handlers 其中的 handlers 是错误信息中红字显示的节点名称。 如果modules也被锁定，可以运行 %windir%\\system32\\inetsrv\\appcmd unlock config -section:system.webServer/modules 注意：要以管理员身份运行才可以，默认不是管理员身份，方法，在开始菜单中的搜索程序与文件输入CMD，就会在上方出现一个CMD.EXE，在这个CMD.EXE文件上点击键，选择“以管理员身份运行”，打开命令行窗口，输入以上命令即可。 另外，如果使用Asp.net的朋友，在安装IIS7的时候一定记得勾选Asp.net，默认不选，也会出现类似的错误信息","comments":true,"tags":[{"name":"IIS","slug":"IIS","permalink":"http://ioridy.github.io/tags/IIS/"},{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://ioridy.github.io/tags/ASP-NET/"}]},{"title":"iFrame在iOS上宽度设置失效","date":"2016-08-15T08:51:35.000Z","path":"2016/08/15/iFrame在iOS上宽度设置失效/","text":"在用iFrame嵌套其他页面时，发现在iOS上不管怎么设置，宽度都不起作用（Android），搜索了下解决方案，记录下： ####1.在iframe标签中，加上scrolling强制没有滚动条 （已测试OK） &lt;iframe src=&quot;&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; ####2.采用width: 1px !important (暂未测试) 用最高的权限改变iframe的宽（如果不用这个，子页面元素的宽会将iframe撑开），如果再需要改变iframe的宽，可以选择min-width，或者使用width:XXpx !important","comments":true,"tags":[{"name":"iFrame","slug":"iFrame","permalink":"http://ioridy.github.io/tags/iFrame/"}]},{"title":"ASP.NET调用C Dll部署服务器出错","date":"2015-09-19T01:51:32.000Z","path":"2015/09/19/ASP调用C的Dll部署服务器出错/","text":"ASP.NET中调用c/c++ Dll，在本地测试OK，部署服务器运行出错，搜索了下解决方案，记录下： 方法1：控制面板-&gt;管理工具-&gt;Internet 信息服务(IIS)管理器-&gt;应用程序池-&gt;项目右击-&gt;高级设置-&gt;启用32位应用程序 改为true; 方法2:在VS2012调用64位IIS Express，运行regedit，在 HKEY_CURRENT_USER\\Software\\Microsoft\\VisualStudio\\11.0\\WebProjects\\ 下添加DWORD值 “Use64BitIISExpress”, 值为1","comments":true,"tags":[{"name":"IIS","slug":"IIS","permalink":"http://ioridy.github.io/tags/IIS/"},{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://ioridy.github.io/tags/ASP-NET/"},{"name":"DLL","slug":"DLL","permalink":"http://ioridy.github.io/tags/DLL/"}]},{"title":"Hexo小技巧","date":"2015-07-20T10:48:09.000Z","path":"2015/07/20/Hexo的yilia主题账户链接图标颜色不对/","text":"刚开始使用Hexo，记录下遇到的小问题 Yilia主题个人链接图标颜色问题前些天配置好hexo后，添加了微博，知乎和github的个人链接，但是发布看了之后，发现只有github的颜色是亮的，其他2个都是灰色的，以为是自己的链接地址有问题自动判断不正确显示的灰色，后来反复确认链接是OK的，但是图标颜色确实是灰的 后来就用chrome看了下css的样式，然后找到main.styl文件，直接搜索weibo，看了下css的颜色那里直接写的就是灰色，手动自己修改成喜欢的颜色，然后重新发布下，查看预览OK！ themes/yilia/source/css/_partial/main.styl PS：其他的icon可以根据实际需要同样调整 发布的时候提示：ERROR Process failed这个我一开始没头绪，还搜索了下，没找到答案，静下来想了下，就想到我出错最多的情况：忘记加空格。 貌似这个语法要求巨严格，所有的设置项都变必须要加空格，我发布文章错误就是因为tags:后边忘记加空格了！","comments":true,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://ioridy.github.io/tags/Hexo/"}]},{"title":"stackoverflow访问问题","date":"2015-07-13T08:51:35.000Z","path":"2015/07/13/stackoverflow访问问题/","text":"访问StackOverFlow出现以下2个问题，搜索了下解决方案，记录下： ####1.访问速度慢 静态资源遭墙了，导致访问巨慢，还有排版等显示格式问题，解决办法：手动修改本机host Linux: /etc/hosts WIN: C:\\Windows\\System32\\drivers\\etc\\hosts 加入如下行： 190.93.247.58 cdn.sstatic.net 198.252.206.140 sstatic.net 意为将cdn.sstatic.net解析到sstatic.net。这样StackOverflow便恢复正常啦！ 如果发现访问:https://stackoverflow.com 下面的页面，比如登陆注册页面时样式依然有问题。原来https网站外链的资源也必须是https的，所以css的请求都到了https://cdn.sstatic.net 。而这样修改host后https证书会通不过校验，所以需要手动访问次https://cdn.sstatic.net 并信任证书。然后再访问登陆注册页面就OK了。 PS：Mac在终端使用vi命令修改时，务必加上sudo，否则无法保存 ####2.出现 Solution for the problem of stackoverflow “requires external JavaScript from another domain” 错误提示 此问题也是因为stackoverflow使用的google的jquey库等，被墙后无法访问，Mac上装个safari 插件：Redirector.非常简单添加下面2句到”from_url,to_url”后面即可 ajax.googleapis.com,ajax.useso.com fonts.googleapis.com,fonts.useso.com","comments":true,"tags":[{"name":"stackoverflow","slug":"stackoverflow","permalink":"http://ioridy.github.io/tags/stackoverflow/"}]},{"title":"hexo配置中问题记录","date":"2015-07-10T07:36:09.000Z","path":"2015/07/10/hexo配置中问题记录/","text":"经过一上午的折腾终于按照自己的喜好配置完了Hexo，感觉很好！这是第一篇文章，主要是记录下我在按照网络上的教程操作时遇到的问题（本人是Mac系统OSX 10.10.4），主要有以下几个： #####1. 安装了完成后，本地调试OK，但是运行hexo deploy 后没有任何反应和反馈 此问题后来还是经过网络搜索，发现hexo的配置文件语法要求，没一个参数的”:”后边必须要有个半角的空格，后来修改后终于有反馈，但是提示我下面的error。 ####2. 提示github无效 此问题经过搜索发现，新版的hexo（貌似是3.0以后吧）type项由以前的github须改为git。所以在按照网络上的教程操作时，请注意教程的时间以及你所使用的version。 PS：新版的hexo支持简写的命令，比如hexo deploy直接用hexo d就ok！ ####3. 多说样式设置 按照网上的教程，修改了embed.js，添加了多说后台的自定义css后，只显示js中定义的UA，设置在多说的自定义css完全没有起作用，通过chrome查看，通过对比排查，发现插入的关于多说js的部分short_name值不对，根据js查找如下文件： /Users/ioridy/Project/Hexo/themes/yilia/layout/_partial/post/duoshuo.ejs 修改一下部分 var duoshuoQuery = &#123;short_name:&quot;&lt;%=theme.duoshuo%&gt;&quot;&#125;; short_name为多说后台设置的key，我使用的yilia主题此处不对，请根据自己使用的主题设置，或者直接写成自己的key。 ###最后想说下，Hexo确实很cool，喜欢^^","comments":true,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://ioridy.github.io/tags/Hexo/"}]}]